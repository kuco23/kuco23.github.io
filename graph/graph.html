<!DOCTYPE html>

<html>
<head>

  <title>Graphs and DFS</title>
  <meta name='viewport' content='width=device-width, initial-scale=1.0' charset='utf-8' />
  <link rel='stylesheet' type='text/css' href='main.css' />
  <script src = '../jquery-3.3.1.min.js'></script>

  <style>
  </style>

  <script>

    function toggleNodeCreationMode(off=false) {
      if (!off) toggleNodeSelectionMode(true);
      if (document.graph.nodeCreationMode || off===true) {
        document.graph.nodeCreationMode = false;
        $('#nodeCreationBtn').html('TURN ON').css('color', 'lime');
      } else {
        document.graph.nodeCreationMode = true;
        $('#nodeCreationBtn').html('TURN OFF').css('color', 'red');
      }
    }
    function toggleNodeSelectionMode(off=false) {
      if (!off) toggleNodeCreationMode(true);
      if (document.graph.nodeSelectionMode || off===true) {
        document.graph.nodeSelectionMode = false;
        $('#nodeSelectionBtn').html('TURN ON').css('color', 'lime');
      } else {
        document.graph.nodeSelectionMode = true;
        $('#nodeSelectionBtn').html('TURN OFF').css('color', 'red');
      }
    }

    $(document).ready(function() {

      $('#canvus').attr({
        height: window.innerHeight,
        width: window.innerWidth * 0.75
      });

      var canvas = document.getElementById('canvus');
      var context = canvas.getContext('2d');

      function range(a, b) {
        let list = [];
        for (let i = a; i < b; i++) {
          list.push(i);
        } return list;
      }
      function randint(a, b) {
        return a + Math.random() * (b - a);
      }

      function Graph(context, directed = false,
                     node_color='black', edge_color='black', node_radius = 6, edge_width = 2) {
        this.context = context;
        this.canvas_width = context.canvas.width; this.canvas_height = context.canvas.height;
        this.directed = directed;
        this.node_color = node_color; this.edge_color = edge_color;
        this.node_radius = node_radius; this.edge_width = edge_width;
        this.node_placeholder_color = 'rgba(0, 0, 0, 0.2)';

        this.nodeList = [];
        this.edgeList = [];

        this.nodeCreationMode = false;
        this.nodeSelectionMode = false;
        this.selectedNodeA = null;
        this.selectedNodeB = null;
        this.selection_color = 'red';

        function drawCircle(context, x, y, r, color, fill=true) {
          context.beginPath();
          context.arc(x, y, r, 0, 2 * Math.PI);
          if (fill) {
            context.fillStyle = color;
            context.fill();
          } else {
            context.strokeStyle = color;
            context.stroke();
          }
        }
        function Node(context, x, y, radius, color, placeholder_color) {
          this.context = context;
          this.x = x; this.y = y; this.radius = radius;
          this.color = color; this.placeholder_color = placeholder_color;
          this.neighbours = [];

          this.create = function() {
            drawCircle(this.context, this.x, this.y, this.radius, this.color, true);
          };
          this.delete = function() {
            this.context.clearRect(this.x - radius, this.y - radius, 2 * radius, 2 * radius);
            drawCircle(this.context, this.x, this.y, this.radius, this.placeholder_color);
          };
          this.create()
        }
        function Edge(context, node1, node2, color, linewidth, time_to_draw = 0) {
          this.context = context;
          this.node1 = node1; this.node2 = node2;
          node1.neighbours.push(node2); node2.neighbours.push(node1);
          this.linewidth = linewidth;
          this.color = color;
          this.vector = [(this.node2.x - this.node1.x) / 50, (this.node2.y - this.node1.y) / 50]

          this.create = function() {
            this.context.beginPath();
            this.context.moveTo(this.node1.x, this.node1.y);
            this.context.lineTo(this.node2.x, this.node2.y);
            this.context.lineWidth = this.linewidth;
            this.context.fillStyle = this.color;
            this.context.stroke();
          };
          this.unlink = function() {
            for (i = 0; i < this.node1.neighbours.length; i++) {
              if (this.node2 == this.node1.neighbours[i]) this.node1.neighbours.splice(i, 1); break;
            }
            for (i = 0; i < this.node2.neighbours.length; i++) {
              if (this.node1 == this.node2.neighbours[i]) this.node2.neighbours.splice(i, 1); break;
            }
          };
          this.create();
        }
        this.getNodePositions = function() {
          let node_margin = 8 * this.node_radius;
          let nodes_onX = Math.floor(this.canvas_width / (node_margin + 2 * this.node_radius));
          let nodes_onY = Math.floor(this.canvas_height / (node_margin + 2 * this.node_radius));
          let space_leftX = this.canvas_width - (nodes_onX * (node_margin + 2 * this.node_radius));
          let space_leftY = this.canvas_height - (nodes_onY * (node_margin + 2 * this.node_radius));
          let marginSideX = (node_margin + space_leftX) / 2
          let marginSideY = (node_margin + space_leftY) / 2
          let positionList = [];
          for (let i = 0; i < nodes_onY; i++) {
            for (let j = 0; j < nodes_onX; j++) {
              let posXY = [marginSideX + j * (node_margin + 2 * this.node_radius),
                           marginSideY + i * (node_margin + 2 * this.node_radius)];
              drawCircle(this.context, posXY[0], posXY[1], this.node_radius, this.node_placeholder_color, true);
              positionList.push(posXY);
            }
          } return positionList;
        };
        this.drawRandomNode = function() {
          if (this.positionList.length == 0) {
            return null;
          }
          let ran = randint(0, this.positionList.length - 1);
          let XY = this.positionList.splice(ran, 1);
          this.nodeList.push(new Node(this.context, XY[0][0], XY[0][1],
            this.node_radius, this.node_color, this.node_placeholder_color));
        };
        this.clearNode = function(index) {
          if (index >= 0 && index < this.nodeList.length) {
            let node = this.nodeList.splice(index, 1)[0];
            if (node == this.selectedNodeA) this.selectedNodeA = null;
            if (node == this.selectedNodeB) this.selctedNodeB = null;
            node.delete();
            this.positionList.push([node.x, node.y]);
            // delete all the edges connected to this node
            let static_ar = node.neighbours.slice();
            for (let i = 0; i < static_ar.length; i++) {
              let indx = this.getEdgeByCoords(node.x, node.y,
              static_ar[i].x, static_ar[i].y);
              if (indx !== null) this.clearEdge(indx);
            }
          }
        };
        this.clearEdge = function(index) {
          if (index >= 0 && index < this.edgeList.length) {
            this.context.clearRect(0, 0, this.canvas_width, this.canvas_height);
            this.getNodePositions();
            for (i = 0; i < this.nodeList.length; i++) this.nodeList[i].create();
            for (i = 0; i < this.edgeList.length; i++) {
              if (i != index) this.edgeList[i].create();
            }
            this.edgeList.splice(index, 1)[0].unlink();
          }
        };
        this.getOverlappingPosition = function(x, y) {
          for (let i = 0; i < this.positionList.length; i++) {
            let vector = [x - this.positionList[i][0], y - this.positionList[i][1]];
            let vector_norm = Math.pow(Math.pow(vector[0], 2) + Math.pow(vector[1], 2), 0.5);
            if (vector_norm <= node_radius) {
              return i;
            }
          } return null;
        };
        this.getNodeByPosition = function(x, y) {
          for (let i = 0; i < this.nodeList.length; i++) {
            let node = this.nodeList[i];
            let vector = [node.x - x, node.y - y];
            let vector_norm = Math.pow(Math.pow(vector[0], 2) + Math.pow(vector[1], 2), 0.5);
            if (vector_norm <= node.radius) {
              return i;
            }
          } return null;
        };
        this.getEdgeByCoords = function(x1, y1, x2, y2) {
          for (let i = 0; i < this.edgeList.length; i++) {
            if ((this.edgeList[i].node1.x == x1 && this.edgeList[i].node1.y == y1 &&
               this.edgeList[i].node2.x == x2 && this.edgeList[i].node2.y == y2) ||
              (this.edgeList[i].node2.x == x1 && this.edgeList[i].node2.y == y1 &&
               this.edgeList[i].node1.x == x2 && this.edgeList[i].node1.y == y2)) {
              return i;
            }
          } return null;
        };
        this.linkSelected = function() {
          if (this.selectedNodeA !== null && this.selectedNodeB !== null) {
            let edge = this.getEdgeByCoords(this.selectedNodeA.x, this.selectedNodeA.y,
            this.selectedNodeB.x, this.selectedNodeB.y);
            if (edge !== null) return null;
            this.edgeList.push(new Edge(this.context, this.selectedNodeA, this.selectedNodeB,
              this.selection_color, this.edge_width, 2))
            this.selectedNodeA.create();
            this.selectedNodeA = null;
            this.selectedNodeB.create();
            this.selectedNodeB = null;
          }
        };
        this.handleClick = function(x, y) {
          let nodeIndex = this.getNodeByPosition(x, y);
          let nodePosIndex = this.getOverlappingPosition(x, y);
          let node = (nodeIndex !== null) ? this.nodeList[nodeIndex] : null;
          let nodePos = (nodePosIndex !== null) ? this.positionList[nodePosIndex] : null;
          // save and mark the node that was selected
          if (this.nodeSelectionMode && node) {
            let color = null;
            if (this.selectedNodeA == node) {
              this.selectedNodeA = null;
              color = node.color;
            } else if (this.selectedNodeB == node) {
              this.selectedNodeB = null;
              color = node.color;
            } else if (this.selectedNodeA == null) {
              this.selectedNodeA = node;
              color = this.selection_color;
            } else if (this.selectedNodeB == null) {
              this.selectedNodeB = node;
              color = this.selection_color;
            } else {
              this.selectedNodeB.create();
              this.selectedNodeB = node;
              color = this.selection_color;
            }
            drawCircle(this.context, node.x, node.y, node.radius, color);
          } else if (this.nodeCreationMode && nodePos) {
            this.positionList.splice(nodePosIndex, 1);
            this.nodeList.push(new Node(this.context, nodePos[0], nodePos[1],
            this.node_radius, this.node_color, this.node_placeholder_color));
          } else if (this.nodeCreationMode && node) {
            this.clearNode(nodeIndex);
          }
        };
        this.delete = function() {
          this.context.clearRect(0, 0, this.canvas_width, this.canvas_height);
          this.nodeList = [];
          this.edgeList = [];
          this.positionlist = this.getNodePositions();
        };

        this.positionList = this.getNodePositions();
      }

      document.graph = new Graph(context, false);

      canvas.addEventListener('click', function(event) {
        document.graph.handleClick(event.pageX, event.pageY);
      });
      window.addEventListener('keydown', function(event) {
        if (event.keyCode == 32) document.graph.linkSelected();
      });
      window.onresize = function() {
        0;
      };

    });

  </script>

</head>
<body>

<canvas id='canvus' width=500 height=500>
</canvas>

<div class='options'>
  <div class='title-button'>
    <span title='Toggle creation and removal of a node by clicking
    on its position or its placeholder'>Manual Node Creation Mode</span>
    <button onclick = 'toggleNodeCreationMode();' id='nodeCreationBtn'>TURN ON</button>
  </div>
  <div class='title-button'>
    <span title='select two nodes by clicking on them and
    then connect them by clicking Connect'>Manual Node Selection Mode</span>
    <button onclick = 'toggleNodeSelectionMode();' id='nodeSelectionBtn'>TURN ON</button>
    <div class='flex-buttons'>
      <button onclick = 'graph.linkSelected();'>Connect</button>
    </div>
  </div>
  <button onclick = 'graph.drawRandomNode();'>Add Node</button>
  <button onclick = 'graph.clearNode(graph.nodeList.length - 1);'>Delete last node</button>
  <button onclick = 'graph.delete();'>Clear</button>
</div>

<div class='screenToSmall'>
  Sorry, but your screen is too small
</div>

</body>
</html>
