<!DOCTYPE html>

<html>
<head>

  <title>Graphs and DFS</title>
  <meta name='viewport' content='width=device-width, initial-scale=1.0' charset='utf-8' />
  <link rel='stylesheet' type='text/css' href='main.css' />
  <script src = '../jquery-3.3.1.min.js'></script>

  <style>
  </style>

  <script>

    function toggleMode(mode) {
      let modes = ['nodeSelectionMode', 'nodeCreationMode', 'dfsMode'];
      let button = [['TURN ON', 'lime'], ['TURN OFF', 'red']];
      for (let i = 0; i < modes.length; i++) {
        if (mode != modes[i]) {
          document.graph[modes[i]] = false;
          $('#' + modes[i] + 'Btn').html(button[0][0]).css('color', button[0][1]);
        }
      }
      document.graph[mode] = !document.graph[mode];
      let setsTo = button[Number(document.graph[mode])];
      $('#' + mode + 'Btn').html(setsTo[0]).css('color', setsTo[1]);
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function randint(a, b) {
      return Math.round(a + Math.random() * (b - a));
    }
    function randomChoice(l) {
      return l[randint(0, l.length - 1)];
    }
    function getNorm(vec) {
      return Math.pow(Math.pow(vec[0], 2) + Math.pow(vec[1], 2), 0.5);
    };

    $(document).ready(function() {

      $('#canvus').attr({
        height: window.innerHeight,
        width: window.innerWidth * 0.75
      });

      var canvas = document.getElementById('canvus');
      var context = canvas.getContext('2d');

      function Graph(context,
        node_color='black', edge_color='rgba(0, 0, 0, 0.5)',
        node_radius = 6, edge_width = 2) {

        this.context = context;
        this.node_color = node_color; this.edge_color = edge_color;
        this.node_radius = node_radius; this.edge_width = edge_width;
        this.node_placeholder_color = 'rgba(0, 0, 0, 0.2)';

        this.matrix = []

        this.nodeCreationMode = false;
        this.nodeSelectionMode = false;
        this.selectedNodeA = null;
        this.selectedNodeB = null;
        this.selection_color = 'red';

        this.dfsMode = false;
        this.dfsAnimDelay = 1000;
        this.dfsStartNode = null;
        this.dfs_node_color = 'blue';
        this.dfs_forward_edge_color = 'yellow';
        this.dfs_backtrack_edge_color = 'green';

        // this is set to true during animation
        this.lockdown = false;

        function drawLine(context, x1, y1, x2, y2, linewidth, linecolor) {
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.lineWidth = linewidth;
          context.strokeStyle = linecolor;
          context.stroke();
        }
        function drawLineBetween(context, node1, node2, linewidth, linecolor) {
          drawLine(context, node1.x, node1.y,
            node2.x, node2.y, linewidth, linecolor);
        }
        function drawCircle(context, x, y, r, color, fill=true) {
          context.beginPath();
          context.arc(x, y, r, 0, 2 * Math.PI);
          if (fill) {
            context.fillStyle = color;
            context.fill();
          } else {
            context.strokeStyle = color;
            context.stroke();
          }
        }
        function Node(context, x, y, i, j, radius, color, placeholder_color) {
          this.context = context;
          this.x = x; this.y = y; this.radius = radius;
          this.i = i; this.j = j;
          this.color = color; this.placeholder_color = placeholder_color;
          this.neighbours = [];
          this.create = function(color=this.color) {
            drawCircle(this.context, this.x, this.y,
              this.radius, color, true);
          };
          this.delete = function() {
            this.context.clearRect(this.x - radius,
              this.y - radius, 2 * radius, 2 * radius);
            drawCircle(this.context, this.x, this.y,
              this.radius, this.placeholder_color);
          };
          this.create()
        }
        this.getPositionByIndex = function(i, j) {
          return [this.marginSideX + j * (this.node_margin + 2 * this.node_radius),
                  this.marginSideY + i * (this.node_margin + 2 * this.node_radius)];
        };
        this.getIndexByPosition = function(x, y) { // O(1)
          let j = Math.round((x - this.marginSideX) / (this.node_margin + 2 * this.node_radius));
          let i = Math.round((y - this.marginSideY) / (this.node_margin + 2 * this.node_radius));
          let pos = this.getPositionByIndex(i, j);
          if (getNorm([x - pos[0], y - pos[1]]) <= this.node_radius * 3) {
            return [i, j];
          } return null;
        };
        this.clearNode = function(i, j) {
          if (0 <= i && i < this.matrix.length &&
          0 <= j && j < this.matrix[0].length &&
          this.matrix[i][j] !== null) {
            let node = this.matrix[i][j];
            this.matrix[i][j] = null;
            if (node == this.selectedNodeA) this.selectedNodeA = null;
            if (node == this.selectedNodeB) this.selctedNodeB = null;
            if (node == this.dfsStartNode) this.dfsStartNode = null;
            if (node.neighbours.length == 0) return node.delete();
            // delete the node from all the neighbours's neighbours lists
            for (let i = 0; i < node.neighbours.length; i++) {
              node.neighbours[i].neighbours.splice(node.neighbours[i].neighbours.indexOf(node), 1);
            }
            this.redraw();
          }
        };
        this.linkSelected = function() {
          if (this.selectedNodeA !== null && this.selectedNodeB !== null &&
          this.selectedNodeA.neighbours.indexOf(this.selectedNodeB) == -1) {
            this.selectedNodeA.neighbours.push(this.selectedNodeB);
            this.selectedNodeB.neighbours.push(this.selectedNodeA);
            drawLineBetween(this.context,
              this.selectedNodeA, this.selectedNodeB,
              this.edge_width, this.edge_color);
            this.selectedNodeA.create();
            this.selectedNodeA = null;
            this.selectedNodeB.create();
            this.selectedNodeB = null;
          }
        };
        this.handleClick = function(x, y) {
          let nodeIndex = this.getIndexByPosition(x, y);
          if (!nodeIndex || this.lockdown) return null;
          let i = nodeIndex[0]; let j = nodeIndex[1];
          let node = null; let free_space = null;
          if (this.matrix[i][j]) {
            node = this.matrix[i][j];
          } else {
            free_space = this.getPositionByIndex(i, j);
          }
          // save and mark the node that was selected
          if (this.nodeSelectionMode && node) {
            let color = null;
            if (this.selectedNodeA == node) {
              this.selectedNodeA = null;
              color = node.color;
            } else if (this.selectedNodeB == node) {
              this.selectedNodeB = null;
              color = node.color;
            } else if (this.selectedNodeA == null) {
              this.selectedNodeA = node;
              color = this.selection_color;
            } else if (this.selectedNodeB == null) {
              this.selectedNodeB = node;
              color = this.selection_color;
            } else {
              this.selectedNodeB.create();
              this.selectedNodeB = node;
              color = this.selection_color;
            }
            node.create(color);
          } else if (this.nodeCreationMode && free_space) {
            this.matrix[i][j] = new Node(this.context,
              free_space[0], free_space[1], i, j, this.node_radius,
              this.node_color, this.node_placeholder_color);
          } else if (this.nodeCreationMode && node) {
            this.clearNode(i, j); // one of two times where node is cleared
          } else if (this.dfsMode && node) {
            if (this.dfsStartNode == node) {
              node.create();
              this.dfsStartNode = null;
            } else {
              if (this.dfsStartNode) this.dfsStartNode.create();
              this.dfsStartNode = node;
              node.create(this.dfs_node_color);
            }
          }
        };

        // this 'monkey patches' node with marked attribute and origin
        this.dfs = async function() {
          this.lockdown = true;
          let node = this.dfsStartNode;
          if (!node) return null;
          node.create();
          this.dfsStartNode = null;
          let stack = [node];
          let root_tree = [null];
          while (stack.length) {
            let current_node = stack.splice(stack.length - 1, 1)[0];
            if (!current_node.marked) {
              // open current_node
              await sleep(this.dfsAnimDelay);
              stack.push(current_node);
              root_tree.push(current_node);
              current_node.marked = true;
              for (let i = 0; i < current_node.neighbours.length; i++) {
                if (!current_node.neighbours[i].marked) {
                  stack.push(current_node.neighbours[i]);
                  current_node.neighbours[i].origin = current_node;
                }
              }
              current_node.create(this.dfs_node_color);
              if (current_node.origin) {
                drawLineBetween(this.context,
                  current_node, current_node.origin,
                  this.edge_width, this.dfs_forward_edge_color);
              }
            } else if (current_node == root_tree[root_tree.length - 1]) {
              // close current_node / backtrack
              await sleep(this.dfsAnimDelay);
              root_tree.splice(root_tree.length - 1, 1);
              if (current_node.origin) {
                drawLineBetween(this.context,
                  current_node, current_node.origin,
                  this.edge_width, this.dfs_backtrack_edge_color);
                }
            } else {
              // cross edge
              undefined;
            }
          }
          this.lockdown = false;
          for (let i = 0; i < this.matrix.length; i++) {
            for (let j = 0; j < this.matrix[0].length; j++) {
              if (this.matrix[i][j]) {
                 this.matrix[i][j].marked = undefined;
                 this.matrix[i][j].origin = undefined;
               }
            }
          }
        };

        this.reset = function() {
          if (this.lockdown) return null;
          W = this.context.canvas.width; H = this.context.canvas.height;
          this.node_margin = 8 * this.node_radius;
          this.nodes_onX = Math.floor(W / (this.node_margin + 2 * this.node_radius));
          this.nodes_onY = Math.floor(H / (this.node_margin + 2 * this.node_radius));
          let space_leftX = W - (this.nodes_onX * (this.node_margin + 2 * this.node_radius));
          let space_leftY = H - (this.nodes_onY * (this.node_margin + 2 * this.node_radius));
          this.node_radius = node_radius;
          this.marginSideX = (this.node_margin + space_leftX) / 2;
          this.marginSideY = (this.node_margin + space_leftY) / 2;
          this.matrix = [];
          this.selectedNodeA = null;
          this.selectedNodeB = null;
          this.context.clearRect(0, 0, this.context.canvas.width,
            this.context.canvas.height);
          for (let i = 0; i < this.nodes_onY; i++) {
            this.matrix.push([]);
            for (let j = 0; j < this.nodes_onX; j++) {
              let posXY = this.getPositionByIndex(i, j);
              drawCircle(this.context, posXY[0], posXY[1], this.node_radius,
                this.node_placeholder_color, true);
              this.matrix[i].push(null);
            }
          }
        };
        this.redraw = function() {
          if (this.lockdown) return null;
          this.context.clearRect(0, 0, this.context.canvas.width,
            this.context.canvas.height);
          for (let i = 0; i < this.nodes_onY; i++) {
            for (let j = 0; j < this.nodes_onX; j++) {
              if (this.matrix[i][j] !== null) {
                let node = this.matrix[i][j];
                node.create();
                for (let k = 0; k < node.neighbours.length; k++) {
                  let node2 = this.matrix[i][j].neighbours[k];
                  drawLine(this.context, node.x, node.y, node2.x, node2.y,
                    this.edge_width, this.edge_color);
                }
              } else {
                let pos = this.getPositionByIndex(i, j);
                drawCircle(this.context, pos[0], pos[1], this.node_radius,
                  this.node_placeholder_color, true);
              }
            }
          }
        };
        this.reset();
      }

      document.graph = new Graph(context);

      canvas.addEventListener('click', function(event) {
        document.graph.handleClick(event.pageX, event.pageY);
      });
      window.addEventListener('keydown', function(event) {
        if (event.keyCode == 32) document.graph.linkSelected();
      });
      window.onresize = function() {
        $('#canvus').attr({
          height: window.innerHeight,
          width: window.innerWidth * 0.75
        });
        document.graph.reset();
      };

    });

  </script>

</head>
<body>

<canvas id='canvus' width=500 height=500>
</canvas>

<div class='options'>
  <div class='title-button'>
    <span title='Toggle creation and removal of a node by clicking
    on its position or its placeholder'>Manual Node Creation Mode</span>
    <button onclick = 'toggleMode("nodeCreationMode");' id='nodeCreationModeBtn'>
      TURN ON
    </button>
  </div>
  <div class='title-button'>
    <span title='select two nodes by clicking on them and
    then connect them by clicking Connect or pressing spacebar'>
      Manual Node Selection Mode
    </span>
    <button onclick='toggleMode("nodeSelectionMode");' id='nodeSelectionModeBtn'>
      TURN ON
    </button>
    <button onclick='graph.linkSelected();'>Connect</button>
  </div>
  <div class='title-button'>
    <span>Manual dfs Starting Node Selection Mode</span>
    <button onclick='toggleMode("dfsMode");' id='dfsModeBtn'>
      TURN ON
    </button>
    <button onclick='graph.dfs();'>Run dfs</button>
  </div>
  <button onclick='graph.redraw();'>Remove Coloring</button>
  <button onclick='graph.reset();'>Clear</button>
</div>

<div class='screenToSmall'>
  Sorry, but your screen is too small
</div>

</body>
</html>
