<!DOCTYPE html>

<html>
<head>

  <title>Graphs and DFS</title>
  <meta name='viewport' content='width=device-width, initial-scale=1.0' charset='utf-8' />
  <link rel='stylesheet' type='text/css' href='main.css' />
  <script src = '../jquery-3.3.1.min.js'></script>

  <style>
  </style>

  <script>

    function toggleNodeCreationMode(off=false) {
      if (!off) toggleNodeSelectionMode(true);
      if (document.graph.nodeCreationMode || off===true) {
        document.graph.nodeCreationMode = false;
        $('#nodeCreationBtn').html('TURN ON').css('color', 'lime');
      } else {
        document.graph.nodeCreationMode = true;
        $('#nodeCreationBtn').html('TURN OFF').css('color', 'red');
      }
    }
    function toggleNodeSelectionMode(off=false) {
      if (!off) toggleNodeCreationMode(true);
      if (document.graph.nodeSelectionMode || off===true) {
        document.graph.nodeSelectionMode = false;
        $('#nodeSelectionBtn').html('TURN ON').css('color', 'lime');
      } else {
        document.graph.nodeSelectionMode = true;
        $('#nodeSelectionBtn').html('TURN OFF').css('color', 'red');
      }
    }
    function randint(a, b) {
      return Math.round(a + Math.random() * (b - a));
    }
    function randomChoice(l) {
      return l[randint(0, l.length - 1)];
    }
    function getNorm(vec) {
      return Math.pow(Math.pow(vec[0], 2) + Math.pow(vec[1], 2), 0.5);
    };

    $(document).ready(function() {

      $('#canvus').attr({
        height: window.innerHeight,
        width: window.innerWidth * 0.75
      });

      var canvas = document.getElementById('canvus');
      var context = canvas.getContext('2d');

      function Graph(context, directed = false,
                     node_color='black', edge_color='rgba(0, 0, 0, 0.5)', node_radius = 6, edge_width = 2) {
        this.context = context;
        this.directed = directed;
        this.node_color = node_color; this.edge_color = edge_color;
        this.node_radius = node_radius; this.edge_width = edge_width;
        this.node_placeholder_color = 'rgba(0, 0, 0, 0.2)';

        this.matrix = []
        this.edge_list = [];

        this.nodeCreationMode = false;
        this.nodeSelectionMode = false;
        this.selectedNodeA = null;
        this.selectedNodeB = null;
        this.selection_color = 'red';

        function drawLine(context, x1, y1, x2, y2, linewidth, linecolor) {
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.lineWidth = linewidth;
          context.strokeStyle = linecolor;
          context.stroke();
        }
        function drawCircle(context, x, y, r, color, fill=true) {
          context.beginPath();
          context.arc(x, y, r, 0, 2 * Math.PI);
          if (fill) {
            context.fillStyle = color;
            context.fill();
          } else {
            context.strokeStyle = color;
            context.stroke();
          }
        }
        function Node(context, x, y, i, j, radius, color, placeholder_color) {
          this.context = context;
          this.x = x; this.y = y; this.radius = radius;
          this.i = i; this.j = j;
          this.color = color; this.placeholder_color = placeholder_color;
          this.neighbours = [];
          this.create = function() {
            drawCircle(this.context, this.x, this.y, this.radius, this.color, true);
          };
          this.delete = function() {
            this.context.clearRect(this.x - radius, this.y - radius, 2 * radius, 2 * radius);
            drawCircle(this.context, this.x, this.y, this.radius, this.placeholder_color);
          };
          this.create()
        }
        function Edge(context, node1, node2, color, linewidth, time_to_draw = 0) {
          this.context = context;
          this.node1 = node1; this.node2 = node2;
          node1.neighbours.push(node2); node2.neighbours.push(node1);
          this.linewidth = linewidth;
          this.color = color;
          this.create = function() {
            drawLine(this.context, this.node1.x, this.node1.y,
            this.node2.x, this.node2.y, this.linewidth, this.color);
          };
          this.unlink = function() {
            this.node1.neighbours.splice(this.node1.neighbours.indexOf(this.node2), 1);
            this.node2.neighbours.splice(this.node2.neighbours.indexOf(this.node1), 1);
          };
          this.create();
        }
        this.getPositionByIndex = function(i, j) {
          return [this.marginSideX + j * (this.node_margin + 2 * this.node_radius),
                  this.marginSideY + i * (this.node_margin + 2 * this.node_radius)];
        };
        // O(1)
        this.getIndexByPosition = function(x, y) {
          let j = Math.round((x - this.marginSideX) / (this.node_margin + 2 * this.node_radius));
          let i = Math.round((y - this.marginSideY) / (this.node_margin + 2 * this.node_radius));
          let pos = this.getPositionByIndex(i, j);
          if (getNorm([x - pos[0], y - pos[1]]) <= this.node_radius) {
            return [i, j];
          } return null;
        };
        this.clearNode = function(i, j) {
          if (0 <= i && i < this.matrix.length &&
          0 <= j && j < this.matrix[0].length &&
          this.matrix[i][j] !== null) {
            let node = this.matrix[i][j];
            this.matrix[i][j] = null;
            if (node == this.selectedNodeA) this.selectedNodeA = null;
            if (node == this.selectedNodeB) this.selctedNodeB = null;
            // delete all the edges connected to this node
            let static_neighbours = node.neighbours.slice();
            if (static_neighbours.length == 0) return node.delete();
            for (let i = 0; i < static_neighbours.length; i++) {
              let index = this.getEdgeByCoords(node.x, node.y,
              static_neighbours[i].x, static_neighbours[i].y);
              if (index !== null) this.edge_list.splice(index, 1)[0].unlink();
            }
            this.redraw();
          }
        };
        this.getEdgeByCoords = function(x1, y1, x2, y2) {
          for (let i = 0; i < this.edge_list.length; i++) {
            if ((this.edge_list[i].node1.x == x1 && this.edge_list[i].node1.y == y1 &&
               this.edge_list[i].node2.x == x2 && this.edge_list[i].node2.y == y2) ||
              (this.edge_list[i].node2.x == x1 && this.edge_list[i].node2.y == y1 &&
               this.edge_list[i].node1.x == x2 && this.edge_list[i].node1.y == y2)) {
              return i;
            }
          } return null;
        };
        this.linkSelected = function() {
          if (this.selectedNodeA !== null && this.selectedNodeB !== null) {
            let edge = this.getEdgeByCoords(this.selectedNodeA.x, this.selectedNodeA.y,
            this.selectedNodeB.x, this.selectedNodeB.y);
            if (edge !== null) return null;
            this.edge_list.push(new Edge(this.context, this.selectedNodeA, this.selectedNodeB,
              this.edge_color, this.edge_width, 2))
            this.selectedNodeA.create();
            this.selectedNodeA = null;
            this.selectedNodeB.create();
            this.selectedNodeB = null;
          }
        };
        this.handleClick = function(x, y) {
          let nodeIndex = this.getIndexByPosition(x, y);
          if (!nodeIndex) return null;
          let i = nodeIndex[0]; let j = nodeIndex[1];
          let node = null; let free_space = null;
          if (this.matrix[i][j]) {
            node = this.matrix[i][j];
          } else {
            free_space = this.getPositionByIndex(i, j);
          }
          // save and mark the node that was selected
          if (this.nodeSelectionMode && node) {
            let color = null;
            if (this.selectedNodeA == node) {
              this.selectedNodeA = null;
              color = node.color;
            } else if (this.selectedNodeB == node) {
              this.selectedNodeB = null;
              color = node.color;
            } else if (this.selectedNodeA == null) {
              this.selectedNodeA = node;
              color = this.selection_color;
            } else if (this.selectedNodeB == null) {
              this.selectedNodeB = node;
              color = this.selection_color;
            } else {
              this.selectedNodeB.create();
              this.selectedNodeB = node;
              color = this.selection_color;
            }
            drawCircle(this.context, node.x, node.y, node.radius, color);
          } else if (this.nodeCreationMode && free_space) {
            this.matrix[i][j] = new Node(this.context,
            free_space[0], free_space[1], i, j, this.node_radius, this.node_color,
            this.node_placeholder_color);
          } else if (this.nodeCreationMode && node) {
            this.clearNode(i, j); // one of two times where node is cleared
          }
        };

        // this 'monkey patches' node with marked attribute
        this.dfs = function(node) {
          let stack = [node];
          while (stack.length) {
            let this_node = stack.splice(stack.length - 1, 1);
            this_node.marked = true;
            for (let i = 0; i < this_node.neighbours.length; i++) {
              if (!this.node.neighbours[i].marked) {
                stack.push(this.node.neighbours[i]);
              }
            }
          }
          for (let i = 0; i < this.matrix.length; i++) {
            for (let j = 0; j < this.matrix[0].length; j++) {
              if (this.matrix[i][j]) this.matrix[i][j].marked = undefined;
            }
          }
        };

        this.reset = function() {
          W = this.context.canvas.width; H = this.context.canvas.height;
          this.node_margin = 8 * this.node_radius;
          this.nodes_onX = Math.floor(W / (this.node_margin + 2 * this.node_radius));
          this.nodes_onY = Math.floor(H / (this.node_margin + 2 * this.node_radius));
          let space_leftX = W - (this.nodes_onX * (this.node_margin + 2 * this.node_radius));
          let space_leftY = H - (this.nodes_onY * (this.node_margin + 2 * this.node_radius));
          this.node_radius = node_radius;
          this.marginSideX = (this.node_margin + space_leftX) / 2;
          this.marginSideY = (this.node_margin + space_leftY) / 2;
          this.matrix = [];
          this.selectedNodeA = null;
          this.selectedNodeB = null;
          this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
          for (let i = 0; i < this.nodes_onY; i++) {
            this.matrix.push([]);
            for (let j = 0; j < this.nodes_onX; j++) {
              let posXY = this.getPositionByIndex(i, j);
              drawCircle(this.context, posXY[0], posXY[1], this.node_radius, this.node_placeholder_color, true);
              this.matrix[i].push(null);
            }
          }
        };
        this.redraw = function() {
          this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
          for (let i = 0; i < this.nodes_onY; i++) {
            for (let j = 0; j < this.nodes_onX; j++) {
              if (this.matrix[i][j] !== null) {
                this.matrix[i][j].create();
              } else {
                let pos = this.getPositionByIndex(i, j);
                drawCircle(this.context, pos[0], pos[1], this.node_radius, this.node_placeholder_color, true);
              }
            }
          }
          for (let i = 0; i < this.edge_list.length; i++) {
            if (this.edge_list[i]) this.edge_list[i].create();
          }
        };
        this.reset();
      }

      document.graph = new Graph(context, false);

      canvas.addEventListener('click', function(event) {
        document.graph.handleClick(event.pageX, event.pageY);
      });
      window.addEventListener('keydown', function(event) {
        if (event.keyCode == 32) document.graph.linkSelected();
      });
      window.onresize = function() {
        $('#canvus').attr({
          height: window.innerHeight,
          width: window.innerWidth * 0.75
        });
        document.graph.reset();
      };

    });

  </script>

</head>
<body>

<canvas id='canvus' width=500 height=500>
</canvas>

<div class='options'>
  <div class='title-button'>
    <span title='Toggle creation and removal of a node by clicking
    on its position or its placeholder'>Manual Node Creation Mode</span>
    <button onclick = 'toggleNodeCreationMode();' id='nodeCreationBtn'>TURN ON</button>
  </div>
  <div class='title-button'>
    <span title='select two nodes by clicking on them and
    then connect them by clicking Connect'>Manual Node Selection Mode</span>
    <button onclick = 'toggleNodeSelectionMode();' id='nodeSelectionBtn'>TURN ON</button>
    <div class='flex-buttons'>
      <button onclick = 'graph.linkSelected();'>Connect</button>
    </div>
  </div>
  <button onclick = 'graph.drawRandomNode();'>Add Node</button>
  <button onclick = 'graph.clearNode(graph.nodeList.length - 1);'>Delete last node</button>
  <button onclick = 'graph.reset();'>Clear</button>
</div>

<div class='screenToSmall'>
  Sorry, but your screen is too small
</div>

</body>
</html>
