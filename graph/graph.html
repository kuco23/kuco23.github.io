<!DOCTYPE html>

<html>
<head>

  <title>Graphs and DFS</title>
  <meta name='viewport' content='width=device-width, initial-scale=1.0' charset='utf-8' />
  <link rel='stylesheet' type='text/css' href='main.css' />
  <script src = '../jquery-3.3.1.min.js'></script>

  <style>
  </style>

  <script>

    function toggleNodeCreationMode(off=false) {
      if (!off) toggleNodeSelectionMode(true);
      if (document.graph.nodeCreationMode || off===true) {
        document.graph.nodeCreationMode = false;
        $('#nodeCreationBtn').html('TURN ON').css('color', 'lime');
      } else {
        document.graph.nodeCreationMode = true;
        $('#nodeCreationBtn').html('TURN OFF').css('color', 'red');
      }
    }
    function toggleNodeSelectionMode(off=false) {
      if (!off) toggleNodeCreationMode(true);
      if (document.graph.nodeSelectionMode || off===true) {
        document.graph.nodeSelectionMode = false;
        $('#nodeSelectionBtn').html('TURN ON').css('color', 'lime');
      } else {
        document.graph.nodeSelectionMode = true;
        $('#nodeSelectionBtn').html('TURN OFF').css('color', 'red');
      }
    }
    function randint(a, b) {
      return Math.round(a + Math.random() * (b - a));
    }
    function randomChoice(l) {
      return l[randint(0, l.length - 1)];
    }

    $(document).ready(function() {

      $('#canvus').attr({
        height: window.innerHeight,
        width: window.innerWidth * 0.75
      });

      var canvas = document.getElementById('canvus');
      var context = canvas.getContext('2d');

      function Graph(context, directed = false,
                     node_color='black', edge_color='rgba(0, 0, 0, 0.5)', node_radius = 6, edge_width = 2) {
        this.context = context;
        this.directed = directed;
        this.node_color = node_color; this.edge_color = edge_color;
        this.node_radius = node_radius; this.edge_width = edge_width;
        this.node_placeholder_color = 'rgba(0, 0, 0, 0.2)';

        this.edgeList = [];

        this.nodeCreationMode = false;
        this.nodeSelectionMode = false;
        this.selectedNodeA = null;
        this.selectedNodeB = null;
        this.selection_color = 'red';

        function drawCircle(context, x, y, r, color, fill=true) {
          context.beginPath();
          context.arc(x, y, r, 0, 2 * Math.PI);
          if (fill) {
            context.fillStyle = color;
            context.fill();
          } else {
            context.strokeStyle = color;
            context.stroke();
          }
        }
        function Node(context, x, y, radius, color, placeholder_color) {
          this.context = context;
          this.x = x; this.y = y; this.radius = radius;
          this.color = color; this.placeholder_color = placeholder_color;
          this.neighbours = [];

          this.create = function() {
            drawCircle(this.context, this.x, this.y, this.radius, this.color, true);
          };
          this.delete = function() {
            this.context.clearRect(this.x - radius, this.y - radius, 2 * radius, 2 * radius);
            drawCircle(this.context, this.x, this.y, this.radius, this.placeholder_color);
          };
          this.create()
        }
        function Edge(context, node1, node2, color, linewidth, time_to_draw = 0) {
          this.context = context;
          this.node1 = node1; this.node2 = node2;
          node1.neighbours.push(node2); node2.neighbours.push(node1);
          this.linewidth = linewidth;
          this.color = color;

          this.create = function() {
            this.context.beginPath();
            this.context.moveTo(this.node1.x, this.node1.y);
            this.context.lineTo(this.node2.x, this.node2.y);
            this.context.lineWidth = this.linewidth;
            this.context.strokeStyle = this.color;
            this.context.stroke();
          };
          this.unlink = function() {
            this.node1.neighbours.splice(this.node1.neighbours.indexOf(this.node2), 1);
            this.node2.neighbours.splice(this.node2.neighbours.indexOf(this.node1), 1);
          };
          this.create();
        }
        function NodeMatrix(context, node_radius, placeholder_color) {
          this.context = context;
          W = this.context.canvas.width; H = this.context.canvas.height;
          this.node_margin = 8 * node_radius;
          let nodes_onX = Math.floor(W / (this.node_margin + 2 * node_radius));
          let nodes_onY = Math.floor(H / (this.node_margin + 2 * node_radius));
          let space_leftX = W - (nodes_onX * (this.node_margin + 2 * node_radius));
          let space_leftY = H - (nodes_onY * (this.node_margin + 2 * node_radius));
          this.node_radius = node_radius;
          this.marginSideX = (this.node_margin + space_leftX) / 2;
          this.marginSideY = (this.node_margin + space_leftY) / 2;
          this.matrix = [];

          this.getNorm = function(vec) {
            return Math.pow(Math.pow(vec[0], 2) + Math.pow(vec[1], 2), 0.5);
          };
          this.getPositionByIndex = function(i, j) {
            return [this.marginSideX + j * (this.node_margin + 2 * this.node_radius),
                    this.marginSideY + i * (this.node_margin + 2 * this.node_radius)];
          };
          // O(1)
          this.getIndexByPosition = function(x, y) {
            let j = Math.round((x - this.marginSideX) / (this.node_margin + 2 * this.node_radius));
            let i = Math.round((y - this.marginSideY) / (this.node_margin + 2 * this.node_radius));
            let pos = this.getPositionByIndex(i, j);
            if (this.getNorm([x - pos[0], y - pos[1]]) <= this.node_radius) {
              return [i, j];
            } return null;
          };
          this.defaultWeb = function() {
            this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
            for (let i = 0; i < nodes_onY; i++) {
              for (let j = 0; j < nodes_onX; j++) {
                let posXY = this.getPositionByIndex(i, j);
                drawCircle(this.context, posXY[0], posXY[1], this.node_radius, placeholder_color, true);
              }
            }
          };
          for (let i = 0; i < nodes_onY; i++) {
            this.matrix.push([]);
            for (let j = 0; j < nodes_onX; j++) {
              let posXY = this.getPositionByIndex(i, j);
              this.matrix[i].push(null);
            }
          }
        }
        // O(n * m) worst case scenario (if every node is taken)
        this.drawRandomNode = function() {
          let randomI = randint(0, this.node_matrix.matrix.length - 1);
          let randomJ = randint(0, this.node_matrix.matrix[0].length - 1);
          let directionList = (Math.random() > 0.5) ? [1, -1] : [-1, 1];
          for (let dirInd = 0; dirInd < 2; dirInd++) {
            let add = directionList[dirInd];
            for (let i = randomI; i >= 0 && i < this.node_matrix.matrix.length; i = i + add) {
              for (let j = randomJ; j >= 0 && j < this.node_matrix.matrix[0].length; j = j + add) {
                if (this.node_matrix.matrix[i][j] == null) {
                  let XY = this.node_matrix.getPositionByIndex(i, j);
                  this.node_matrix.matrix[i][j] = new Node(this.context, XY[0], XY[1],
                  this.node_radius, this.node_color, this.node_placeholder_color);
                  return null;
                }
              }
            }
          }
        };
        this.clearNode = function(i, j) {
          if (0 <= i && i < this.node_matrix.matrix.length &&
          0 <= j && j < this.node_matrix.matrix[0].length &&
          this.node_matrix.matrix[i][j]) {
            let node = this.node_matrix.matrix[i][j];
            node.delete();
            this.node_matrix.matrix[i][j] = null;
            if (node == this.selectedNodeA) this.selectedNodeA = null;
            if (node == this.selectedNodeB) this.selctedNodeB = null;
            // delete all the edges connected to this node
            let static_ar = node.neighbours.slice();
            for (let i = 0; i < static_ar.length; i++) {
              let indx = this.getEdgeByCoords(node.x, node.y,
              static_ar[i].x, static_ar[i].y);
              if (indx !== null) this.clearEdge(indx);
            }
          }
        };
        this.clearEdge = function(index) {
          if (index >= 0 && index < this.edgeList.length) {
            this.node_matrix.defaultWeb();;
            for (i = 0; i < this.node_matrix.matrix.length; i++) {
              for (j = 0; j < this.node_matrix.matrix[i].length; j++) {
                if (this.node_matrix.matrix[i][j]) this.node_matrix.matrix[i][j].create();
              }
            }
            for (i = 0; i < this.edgeList.length; i++) {
              if (i != index) this.edgeList[i].create();
            }
            this.edgeList.splice(index, 1)[0].unlink();
          }
        };
        this.getEdgeByCoords = function(x1, y1, x2, y2) {
          for (let i = 0; i < this.edgeList.length; i++) {
            if ((this.edgeList[i].node1.x == x1 && this.edgeList[i].node1.y == y1 &&
               this.edgeList[i].node2.x == x2 && this.edgeList[i].node2.y == y2) ||
              (this.edgeList[i].node2.x == x1 && this.edgeList[i].node2.y == y1 &&
               this.edgeList[i].node1.x == x2 && this.edgeList[i].node1.y == y2)) {
              return i;
            }
          } return null;
        };
        this.linkSelected = function() {
          if (this.selectedNodeA !== null && this.selectedNodeB !== null) {
            let edge = this.getEdgeByCoords(this.selectedNodeA.x, this.selectedNodeA.y,
            this.selectedNodeB.x, this.selectedNodeB.y);
            if (edge !== null) return null;
            this.edgeList.push(new Edge(this.context, this.selectedNodeA, this.selectedNodeB,
              this.edge_color, this.edge_width, 2))
            this.selectedNodeA.create();
            this.selectedNodeA = null;
            this.selectedNodeB.create();
            this.selectedNodeB = null;
          }
        };
        this.handleClick = function(x, y) {
          let nodeIndex = this.node_matrix.getIndexByPosition(x, y);
          if (!nodeIndex) return null;
          let i = nodeIndex[0]; let j = nodeIndex[1];
          let node = null; let free_space = null;
          if (this.node_matrix.matrix[i][j]) {
            node = this.node_matrix.matrix[i][j];
          } else {
            free_space = this.node_matrix.getPositionByIndex(i, j);
          }
          // save and mark the node that was selected
          if (this.nodeSelectionMode && node) {
            let color = null;
            if (this.selectedNodeA == node) {
              this.selectedNodeA = null;
              color = node.color;
            } else if (this.selectedNodeB == node) {
              this.selectedNodeB = null;
              color = node.color;
            } else if (this.selectedNodeA == null) {
              this.selectedNodeA = node;
              color = this.selection_color;
            } else if (this.selectedNodeB == null) {
              this.selectedNodeB = node;
              color = this.selection_color;
            } else {
              this.selectedNodeB.create();
              this.selectedNodeB = node;
              color = this.selection_color;
            }
            drawCircle(this.context, node.x, node.y, node.radius, color);
          } else if (this.nodeCreationMode && free_space) {
            this.node_matrix.matrix[i][j] = new Node(this.context,
            free_space[0], free_space[1], this.node_radius, this.node_color,
            this.node_placeholder_color);
          } else if (this.nodeCreationMode && node) {
            this.clearNode(i, j); // one of two times where node is cleared
          }
        };
        this.restart = function() {
          this.selectedNodeA = null; this.selectedNodeB = null;
          this.edgeList = [];
          this.node_matrix = new NodeMatrix(this.context, this.node_radius, this.node_placeholder_color);
          this.node_matrix.defaultWeb();
        };
        this.restart();
      }

      document.graph = new Graph(context, false);

      canvas.addEventListener('click', function(event) {
        document.graph.handleClick(event.pageX, event.pageY);
      });
      window.addEventListener('keydown', function(event) {
        if (event.keyCode == 32) document.graph.linkSelected();
      });
      window.onresize = function() {
        $('#canvus').attr({
          height: window.innerHeight,
          width: window.innerWidth * 0.75
        });
        document.graph.restart();
      };

    });

  </script>

</head>
<body>

<canvas id='canvus' width=500 height=500>
</canvas>

<div class='options'>
  <div class='title-button'>
    <span title='Toggle creation and removal of a node by clicking
    on its position or its placeholder'>Manual Node Creation Mode</span>
    <button onclick = 'toggleNodeCreationMode();' id='nodeCreationBtn'>TURN ON</button>
  </div>
  <div class='title-button'>
    <span title='select two nodes by clicking on them and
    then connect them by clicking Connect'>Manual Node Selection Mode</span>
    <button onclick = 'toggleNodeSelectionMode();' id='nodeSelectionBtn'>TURN ON</button>
    <div class='flex-buttons'>
      <button onclick = 'graph.linkSelected();'>Connect</button>
    </div>
  </div>
  <button onclick = 'graph.drawRandomNode();'>Add Node</button>
  <button onclick = 'graph.clearNode(graph.nodeList.length - 1);'>Delete last node</button>
  <button onclick = 'graph.restart();'>Clear</button>
</div>

<div class='screenToSmall'>
  Sorry, but your screen is too small
</div>

</body>
</html>
